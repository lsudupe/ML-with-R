---
title: "PEC1: Algorithm K-NN"
author: "Laura Sudupe Medinilla"
date: '`r format(Sys.Date(),"%e de %B, %Y")`'
output:
  pdf_document:
    toc: TRUE
  html_document:
    toc: TRUE
knit: rmarkdown::render("PEC1: Algorithm K-NN", c("pdf_document", "html_document"),output_file = c("PEC1: Algorithm K-NN","PEC1: Algorithm K-NN"))
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NULL)
```

```{r load_libraries, include=FALSE}
require(knitr)
require(class)
require(caret)
require(caTools)
require(gmodels)
require(base)
require(data.table)
```

```{r}
install.packages("data.table")
```


# The kNN Algorithm

In this markdown we are going to learn about classification using k-NN. Unlike
many classification algorithms, k-NN does not do any learning. It simply stores 
the training data verbatim. Unlabeled test examples are then matched to the most 
similar records in the training set usin a distance function, and the unlabeled
example is assignaed the label of its neighbors.

The strengths and weaknesses of this algorithm are as follows:

| **Strengths**    | **Weaknesses**  | 
| ------------------------ |:------------------------------------------------------- |
|* Simple and effective     |* Does not produce a model, which limits the ability to find novel insights in relationships among features |
| * Makes no assumptions about the underlying data distribution | * Slow classification phase |
| * Fast training phase | * Requires a large amount of memory  
|    | * Nominal features and missing data require additional processing |



# Step 1 - Collecting data

We will utilize the "Protein Secondary Structure" from the Brookhaven National Laboratory (USA).This data includes the protein secondary structures from 101 representative proteins.


```{r data, include=FALSE}
amino <- read.csv("data4.csv", head=TRUE, sep= ";")
amino_one_hot <- read.csv("oh_enc.csv", stringsAsFactors = FALSE)
```


# Step 2 - Exploring and preparing the data

We are going to take a look to our data with `str(amino)`. 
```{r, echo=FALSE}
str(amino, list.len=6)
```
The data is structured with `r nrow(amino)` sequences with `r ncol(amino)` amino acids. We want to see which is the central amino acid structure type. The `table()` output indicates that `r as.numeric(table(amino$V18))[1]` aminos has **coil** structure, `r as.numeric(table(amino$V18))[2]` has **beta-sheet** structure and `r as.numeric(table(amino$V18))[3]` has **alpha-helix** structure.

```{r}
table(amino$V18)
```
We can label the data and check the structure porcentages with `prop.table()`
```{r}
amino$V18 <- factor(amino$V18, levels = c("_", "e", "h"),
              labels=c("coil","beta-sheet","alpha-sheet"))
round(prop.table(table(amino$V18)) * 100, digits = 1)
```
## Data preparation 

### One-hot transformation 

### Creating training and test datasets

We are going to divide our data into two portions: a training dataset that will be used to build the KNN model and a test dataset that will be used to estimate the predictive accuracy of the model. 
```{r}
set.seed(123)

train_indx <- sample(x= 1:nrow(amino_one_hot),
                     size= 0.67*nrow(amino_one_hot),
                     replace=FALSE)
train_data <- amino_one_hot[train_indx,]
test_data <- amino_one_hot[-train_indx,]

label_train_idx <- sample(x=1:nrow(amino),
                          size=0.67*nrow(amino),
                          replace= FALSE)
train_label <- amino$V18[label_train_idx]
test_label <- amino$V18[-label_train_idx]


```


# Step 3 - Training a model on the data

For the classification, we will use a kNN implementation from the `class` package. We use the `knn()` function to classify the test data
```{r}
amino_test_pred <- knn(train= train_data, test= test_data,
                       cl=train_label, k=21)

```

The `knn()` function returns a factor vector of predicted labels for each of the examples in the test dataset, which we have assigned to `amino_test_pred`.


# Step 4 - Evaluating model performance

We need to evaluate how well the predicted classes in the `amino_test_pred` vector match up with the known values in the `test_label` vector.
To these purpose, we can use the `CrossTable()` function. We will create a cross tabulation indicating the agreement between two vectors.


```{r}
CrossTable(x=test_label, y=amino_test_pred, prop.chisq=FALSE)
```
The cell percentage in the table indicate the portion of values that fall into four categories. In the top-left, these `r conf.mat$t[1,1]` of `r sum(conf.mat$t)`, cell we have the number of values the KNN algorithm correctly identified as coil. In the diagonal we have the true posiive values, for example, these `r conf.mat$t[3,3]` of `r sum(conf.mat$t)`, shows values the KNN correctly identified as alpha-sheet.

In the case of `r conf.mat$t[2,1]` examples are false negatives, the predicted value were coil but the structure were beta-sheet. The same happens with `r conf.mat$t[3,1]` of `r sum(conf.mat$t)`, the predicted values were coil but the structure were alpha-sheet. 

On the other side, a total of `r conf.mat$t[2,3]` out of `r sum(conf.mat$t)` were incorrectly classified by the KNN algorithm like alpha-sheet.


# Step 5 - Improving the model performance

We will try several different values for **k**, (k = 1, 3, 5, 7, 11), to examine the performance. Using the previous test and training datasets, the same `r tr` records were classified. The number of false negatives and false positives are shown for each iteration.

```{r, include=FALSE}

ks <- c(1, 3, 5, 7, 11)
resum <- data.frame(ks, FN=NA, FP=NA, mal_clas=NA)

j <- 0
for (i in ks){
  j <- j +1
  amino_test_pred <- knn(train = train_data, test = test_data, cl = train_label, k=i)
  conf.mat <- CrossTable(x = test_label, y = amino_test_pred, prop.chisq=FALSE)
  
  resum[j,2:4] <- c(conf.mat$t[2,1], conf.mat$t[1,2], ((conf.mat$t[1,2]+conf.mat$t[2,1])/sum(conf.mat$t))*100)
}

```

```{r, echo=FALSE}
kable(resum, col.names=c("k value", "# false negatives", 
      "# false positives", "% classified Incorrectly"),
      align= c("l","c","c","c"))
```
The 11NN aproach was able yo avoid a lot of false positives at the expense of adding false negatives. In these cases, the 1NN aproach has the higher porcentage os classified incorrectly.



# Step 7 - Prove our KNN classifier with different labels


We know the alpha-helix and beta-sheet are both non-coil structures. We are going to performe the same algorithm for these labels.

```{r}
# copy amino dataframe 
aminocoil <- copy(amino)

#re-label and check the porcentages

aminocoil$V18 <- factor(amino$V18, levels = c("coil", "beta-sheet", "alpha-sheet"),
              labels=c("coil","no-coil","no-coil"))

round(prop.table(table(aminocoil$V18)) * 100, digits = 1)


```

## Creating training and test datasets

We are going to divide our data into two portions: a training dataset that will be used to build the KNN model and a test dataset that will be used to estimate the predictive accuracy of the model. 


```{r}
set.seed(123)

train_indx_coil <- sample(x= 1:nrow(amino_one_hot),
                     size= 0.67*nrow(amino_one_hot),
                     replace=FALSE)
train_data_coil <- amino_one_hot[train_indx,]
test_data_coil <- amino_one_hot[-train_indx,]

label_train_idx_coil <- sample(x=1:nrow(aminocoil),
                          size=0.67*nrow(aminocoil),
                          replace= FALSE)
train_label_coil <- aminocoil$V18[label_train_idx_coil]
test_label_coil <- aminocoil$V18[-label_train_idx_coil]
```

```{r, include=FALSE}

ks2 <- c(1, 3, 5, 7, 11)
resum2 <- data.frame(ks2, FN=NA, FP=NA, mal_clas=NA)

j <- 0
for (i in ks2){
  j <- j +1
  aminocoil_test_pred <- knn(train = train_data_coil, test = test_data_coil, cl = train_label_coil, k=i)
  conf.mat2 <- CrossTable(x = test_label_coil, y = aminocoil_test_pred, prop.chisq=FALSE)
  
  resum2[j,2:4] <- c(conf.mat2$t[2,1], conf.mat2$t[1,2], ((conf.mat2$t[1,2]+conf.mat2$t[2,1])/sum(conf.mat2$t))*100)
}

```

```{r, echo=FALSE}
kable(resum2, col.names=c("k value", "# false negatives", 
      "# false positives", "% classified Incorrectly"),
      align= c("l","c","c","c"))

```
The Receiver Operating Characteristic curve is ussed to examine the trade-off between the detection of true positives, whiile avoiding the false positives. we are goint to calculate de AUC from all the k

```{r}
# ROC and AUC for k=1
aminocoil_test_pred1 <- knn(train = train_data_coil, test = test_data_coil, cl = train_label_coil, k=1,prob = TRUE)
prob1 <- attr(aminocoil_test_pred1, "prob")
labels1 <- factor(test_label_coil, labels = c(0,1))

roc1 <- pROC::roc(labels1, prob1, auc= TRUE, ci=TRUE)
print(roc1)

pROC::plot.roc( roc1, legacy.axes = TRUE, print.thres = "best", print.auc = TRUE,
          auc.polygon = FALSE, max.auc.polygon = FALSE, auc.polygon.col="gainsboro",
          col = 2, grid = TRUE )

```


```{r}
# ROC and AUC for k=3
aminocoil_test_pred3 <- knn(train = train_data_coil, test = test_data_coil, cl = train_label_coil, k=3,prob = TRUE)
prob3 <- attr(aminocoil_test_pred3, "prob")
labels3 <- factor(test_label_coil, labels = c(0,1))

roc3 <- pROC::roc(labels3, prob3, auc= TRUE, ci=TRUE)
print(roc3)

pROC::plot.roc( roc3, legacy.axes = TRUE, print.thres = "best", print.auc = TRUE,
          auc.polygon = FALSE, max.auc.polygon = FALSE, auc.polygon.col="gainsboro",
          col = 2, grid = TRUE )
```

```{r}
# ROC and AUC for k=5
aminocoil_test_pred5 <- knn(train = train_data_coil, test = test_data_coil, cl = train_label_coil, k=5,prob = TRUE)
prob5 <- attr(aminocoil_test_pred5, "prob")
labels5 <- factor(test_label_coil, labels = c(0,1))

roc5 <- pROC::roc(labels5, prob5, auc= TRUE, ci=TRUE)
print(roc5)

pROC::plot.roc( roc5, legacy.axes = TRUE, print.thres = "best", print.auc = TRUE,
          auc.polygon = FALSE, max.auc.polygon = FALSE, auc.polygon.col="gainsboro",
          col = 2, grid = TRUE )
```


```{r}
# ROC and AUC for k=7
aminocoil_test_pred7 <- knn(train = train_data_coil, test = test_data_coil, cl = train_label_coil, k=7,prob = TRUE)
prob7 <- attr(aminocoil_test_pred7, "prob")
labels7 <- factor(test_label_coil, labels = c(0,1))

roc7 <- pROC::roc(labels7, prob7, auc= TRUE, ci=TRUE)
print(roc7)

pROC::plot.roc( roc7, legacy.axes = TRUE, print.thres = "best", print.auc = TRUE,
          auc.polygon = FALSE, max.auc.polygon = FALSE, auc.polygon.col="gainsboro",
          col = 2, grid = TRUE )
```

```{r}
# ROC and AUC for k=11
aminocoil_test_pred11 <- knn(train = train_data_coil, test = test_data_coil, cl = train_label_coil, k=11,prob = TRUE)
prob11 <- attr(aminocoil_test_pred11, "prob")
labels11 <- factor(test_label_coil, labels = c(0,1))

roc11 <- pROC::roc(labels11, prob11, auc= TRUE, ci=TRUE)
print(roc11)

pROC::plot.roc( roc11, legacy.axes = TRUE, print.thres = "best", print.auc = TRUE,
          auc.polygon = FALSE, max.auc.polygon = FALSE, auc.polygon.col="gainsboro",
          col = 2, grid = TRUE )
```








